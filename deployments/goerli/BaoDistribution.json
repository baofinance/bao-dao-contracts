{
  "address": "0x96cdF727f4662776a2EfbBd63E6c0777e458B80E",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_baoToken",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_votingEscrow",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "_merkleRoot",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "_treasury",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "DistributionAlreadyStarted",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "DistributionEndedEarly",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_account",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        },
        {
          "internalType": "bytes32[]",
          "name": "_proof",
          "type": "bytes32[]"
        }
      ],
      "name": "InvalidProof",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidTimestamp",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ZeroClaimable",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "alreadyLocked",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "outsideLockRange",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "_account",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        }
      ],
      "name": "DistributionEnded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "_account",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        }
      ],
      "name": "DistributionLocked",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "_account",
          "type": "address"
        }
      ],
      "name": "DistributionStarted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "_account",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        }
      ],
      "name": "TokensClaimed",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "baoToken",
      "outputs": [
        {
          "internalType": "contract IERC20",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "claim",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_account",
          "type": "address"
        },
        {
          "internalType": "uint64",
          "name": "_timestamp",
          "type": "uint64"
        }
      ],
      "name": "claimable",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "c",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_amountOwedTotal",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_daysSinceStart",
          "type": "uint256"
        }
      ],
      "name": "distCurve",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "distributions",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "dateStarted",
          "type": "uint64"
        },
        {
          "internalType": "uint64",
          "name": "dateEnded",
          "type": "uint64"
        },
        {
          "internalType": "uint64",
          "name": "lastClaim",
          "type": "uint64"
        },
        {
          "internalType": "uint256",
          "name": "amountOwedTotal",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "endDistribution",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_time",
          "type": "uint256"
        }
      ],
      "name": "lockDistribution",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "lockStatus",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "merkleRoot",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32[]",
          "name": "_proof",
          "type": "bytes32[]"
        },
        {
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        }
      ],
      "name": "startDistribution",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "treasury",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "votingEscrow",
      "outputs": [
        {
          "internalType": "contract IVotingEscrow",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xb65bfb606c19927b617bdadc78bd0bd2ae1989eb97347a6bda2e1642fed84811",
  "receipt": {
    "to": null,
    "from": "0x3E57Db6CaA442F63bD5dCd2F5C510864E3497aD9",
    "contractAddress": "0x96cdF727f4662776a2EfbBd63E6c0777e458B80E",
    "transactionIndex": 60,
    "gasUsed": "1059067",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xeb8aa4190f7ccc72d277fb1c393ff569851bf14651c911578847c05bef687a0e",
    "transactionHash": "0xb65bfb606c19927b617bdadc78bd0bd2ae1989eb97347a6bda2e1642fed84811",
    "logs": [],
    "blockNumber": 7799369,
    "cumulativeGasUsed": "24003412",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x1b816ba6d0d09f618045fa91889b7a672c437992",
    "0xe5bab608C3c26a8D12bfB38E210b2AC3B2F767D7",
    "0x41c02385a07002f9d8fd88c8fb950c308c6f7bf7c748b57ae9b892e291900363",
    "0x3dFc49e5112005179Da613BdE5973229082dAc35"
  ],
  "numDeployments": 1,
  "solcInputHash": "5360aa856a14dec17805fdd7597ecd8e",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_baoToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_votingEscrow\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"DistributionAlreadyStarted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DistributionEndedEarly\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_proof\",\"type\":\"bytes32[]\"}],\"name\":\"InvalidProof\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTimestamp\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroClaimable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"alreadyLocked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"outsideLockRange\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"DistributionEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"DistributionLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"DistributionStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TokensClaimed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"baoToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_timestamp\",\"type\":\"uint64\"}],\"name\":\"claimable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"c\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountOwedTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_daysSinceStart\",\"type\":\"uint256\"}],\"name\":\"distCurve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"distributions\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"dateStarted\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"dateEnded\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"lastClaim\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"amountOwedTotal\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endDistribution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"lockDistribution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lockStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"merkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"startDistribution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votingEscrow\",\"outputs\":[{\"internalType\":\"contract IVotingEscrow\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"claimable(address,uint64)\":{\"params\":{\"_account\":\"Account address to query.\",\"_timestamp\":\"Timestamp to query.\"},\"returns\":{\"c\":\"_account's claimable tokens, scaled by 1e18.\"}},\"constructor\":{\"params\":{\"_baoToken\":\"Token to distribute.\",\"_merkleRoot\":\"Merkle root to verify accounts' inclusion and amount owed when starting their distribution.\",\"_votingEscrow\":\"vote escrow BAO contract\"}},\"distCurve(uint256,uint256)\":{\"params\":{\"_amountOwedTotal\":\"Total amount of tokens owed, scaled by 1e18.\",\"_daysSinceStart\":\"Time since the start of the distribution, scaled by 1e18.\"},\"returns\":{\"_amount\":\"Amount of tokens accrued on the distribution curve, assuming the time passed is _daysSinceStart.\"}},\"startDistribution(bytes32[],uint256)\":{\"params\":{\"_amount\":\"Amount of tokens msg.sender is owed. Used to generate the merkle tree leaf.\",\"_proof\":\"Merkle proof to verify msg.sender's inclusion and claimed amount.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"claim()\":{\"notice\":\"Claim all tokens that have been accrued since msg.sender's last claim.\"},\"claimable(address,uint64)\":{\"notice\":\"Get how many tokens an account is able to claim at a given timestamp. 0 = now. This function takes into account the date of the account's last claim, and returns the amount of tokens they've accrued since.\"},\"constructor\":{\"notice\":\"Create a new BaoDistribution contract.\"},\"distCurve(uint256,uint256)\":{\"notice\":\"Get the amount of tokens that would have been accrued along the distribution curve, assuming _daysSinceStart days have passed and the account has never claimed. f(x) = 0 <= x <= 1095 : (2x/219)^2\"},\"endDistribution()\":{\"notice\":\"Claim all tokens that have been accrued since msg.sender's last claim AND the rest of the total locked amount owed immediately at a pre-defined slashed rate. Slash Rate: days_since_start <= 365: (100 - .01369863013 * days_since_start)% days_since_start > 365: 95%\"},\"lockDistribution(uint256)\":{\"notice\":\"Lock all tokens that have NOT been claimed since msg.sender's last claim The Lock into veBAO will be set at _time with this function in-line with length of distribution curve (minimum of 3 years)\"},\"startDistribution(bytes32[],uint256)\":{\"notice\":\"Starts the distribution of BAO for msg.sender.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/BaoDistribution.sol\":\"BaoDistribution\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/BaoDistribution.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity >=0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Tree proofs.\\n *\\n * The proofs can be generated using the JavaScript library\\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\\n *\\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the merkle tree could be reinterpreted as a leaf value.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {verify}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function verifyCalldata(\\n        bytes32[] calldata proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProofCalldata(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processProof}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Returns true if the `leaves` can be proved to be a part of a Merkle tree defined by\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerify(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProof(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {multiProofVerify}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerifyCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the root of a tree reconstructed from `leaves` and the sibling nodes in `proof`,\\n     * consuming from one or the other at each step according to the instructions given by\\n     * `proofFlags`.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProof(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proof.length - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value for the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            return hashes[totalHashes - 1];\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processMultiProof}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProofCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proof.length - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value for the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            return hashes[totalHashes - 1];\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\\n\\n/// @notice Gas optimized reentrancy protection for smart contracts.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/ReentrancyGuard.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\\nabstract contract ReentrancyGuard {\\n    uint256 private locked = 1;\\n\\n    modifier nonReentrant() {\\n        require(locked == 1, \\\"REENTRANCY\\\");\\n\\n        locked = 2;\\n\\n        _;\\n\\n        locked = 1;\\n    }\\n}\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\nlibrary FixedPointMathLibrary {\\n    /*//////////////////////////////////////////////////////////////\\n                    SIMPLIFIED FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide z by the denominator.\\n            z := div(z, denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // First, divide z - 1 by the denominator and add 1.\\n            // We allow z - 1 to underflow if z is 0, because we multiply the\\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\\n        }\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 scalar\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := scalar\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store scalar in z for now.\\n                    z := scalar\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, scalar)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Revert immediately if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, scalar)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, scalar)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        assembly {\\n            // Start off with z at 1.\\n            z := 1\\n\\n            // Used below to help find a nearby power of 2.\\n            let y := x\\n\\n            // Find the lowest power of 2 that is at least sqrt(x).\\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\\n                y := shr(128, y) // Like dividing by 2 ** 128.\\n                z := shl(64, z) // Like multiplying by 2 ** 64.\\n            }\\n            if iszero(lt(y, 0x10000000000000000)) {\\n                y := shr(64, y) // Like dividing by 2 ** 64.\\n                z := shl(32, z) // Like multiplying by 2 ** 32.\\n            }\\n            if iszero(lt(y, 0x100000000)) {\\n                y := shr(32, y) // Like dividing by 2 ** 32.\\n                z := shl(16, z) // Like multiplying by 2 ** 16.\\n            }\\n            if iszero(lt(y, 0x10000)) {\\n                y := shr(16, y) // Like dividing by 2 ** 16.\\n                z := shl(8, z) // Like multiplying by 2 ** 8.\\n            }\\n            if iszero(lt(y, 0x100)) {\\n                y := shr(8, y) // Like dividing by 2 ** 8.\\n                z := shl(4, z) // Like multiplying by 2 ** 4.\\n            }\\n            if iszero(lt(y, 0x10)) {\\n                y := shr(4, y) // Like dividing by 2 ** 4.\\n                z := shl(2, z) // Like multiplying by 2 ** 2.\\n            }\\n            if iszero(lt(y, 0x8)) {\\n                // Equivalent to 2 ** z.\\n                z := shl(1, z)\\n            }\\n\\n            // Shifting right by 1 is like dividing by 2.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // Compute a rounded down version of z.\\n            let zRoundDown := div(x, z)\\n\\n            // If zRoundDown is smaller, use it.\\n            if lt(zRoundDown, z) {\\n                z := zRoundDown\\n            }\\n        }\\n    }\\n}\\n\\n\\ninterface IVotingEscrow {\\n    function create_lock_for(address _to, uint256 _value, uint256 _unlock_time) external;\\n}\\n\\n\\ncontract BaoDistribution is ReentrancyGuard {\\n\\n    // -------------------------------\\n    // VARIABLES\\n    // -------------------------------\\n\\n    //BaoToken public baoToken;\\n    IERC20 public baoToken;\\n    IVotingEscrow public votingEscrow;\\n    mapping(address => DistInfo) public distributions;\\n    mapping(address => bool) public lockStatus;\\n    address public treasury;\\n\\n    // -------------------------------\\n    // CONSTANTS\\n    // -------------------------------\\n\\n    bytes32 public immutable merkleRoot;\\n\\n    // -------------------------------\\n    // STRUCTS\\n    // -------------------------------\\n\\n    struct DistInfo {\\n        uint64 dateStarted;\\n        uint64 dateEnded;\\n        uint64 lastClaim;\\n        uint256 amountOwedTotal;\\n    }\\n\\n    // -------------------------------\\n    // EVENTS\\n    // -------------------------------\\n\\n    event DistributionStarted(address _account);\\n    event TokensClaimed(address _account, uint256 _amount);\\n    event DistributionEnded(address _account, uint256 _amount);\\n    event DistributionLocked(address _account, uint256 _amount);\\n\\n    // -------------------------------\\n    // CUSTOM ERRORS\\n    // -------------------------------\\n\\n    error DistributionAlreadyStarted();\\n    error DistributionEndedEarly();\\n    error InvalidProof(address _account, uint256 _amount, bytes32[] _proof);\\n    error ZeroClaimable();\\n    error InvalidTimestamp();\\n    error outsideLockRange();\\n    error alreadyLocked();\\n\\n    /**\\n     * Create a new BaoDistribution contract.\\n     *\\n     * @param _baoToken Token to distribute.\\n     * @param _votingEscrow vote escrow BAO contract\\n     * @param _merkleRoot Merkle root to verify accounts' inclusion and amount owed when starting their distribution.\\n     */\\n    constructor(address _baoToken, address _votingEscrow ,bytes32 _merkleRoot, address _treasury) {\\n        baoToken = IERC20(_baoToken);\\n        votingEscrow = IVotingEscrow(_votingEscrow);\\n        merkleRoot = _merkleRoot;\\n        treasury = _treasury;\\n    }\\n\\n    // -------------------------------\\n    // PUBLIC FUNCTIONS\\n    // -------------------------------\\n\\n    /**\\n     * Starts the distribution of BAO for msg.sender.\\n     *\\n     * @param _proof Merkle proof to verify msg.sender's inclusion and claimed amount.\\n     * @param _amount Amount of tokens msg.sender is owed. Used to generate the merkle tree leaf.\\n     */\\n    function startDistribution(bytes32[] memory _proof, uint256 _amount) external {\\n        if (distributions[msg.sender].dateStarted != 0) {\\n            revert DistributionAlreadyStarted();\\n        } else if (!verifyProof(_proof, keccak256(abi.encodePacked(msg.sender, _amount)))) {\\n            revert InvalidProof(msg.sender, _amount, _proof);\\n        }\\n\\n        uint64 _now = uint64(block.timestamp);\\n        distributions[msg.sender] = DistInfo(\\n            _now,\\n            0,\\n            _now,\\n            _amount / 1000\\n        );\\n        emit DistributionStarted(msg.sender);\\n    }\\n\\n    /**\\n     * Claim all tokens that have been accrued since msg.sender's last claim.\\n     */\\n    function claim() external nonReentrant {\\n        uint256 _claimable = claimable(msg.sender, 0);\\n        if (_claimable == 0) {\\n            revert ZeroClaimable();\\n        }\\n\\n        // Update account's DistInfo\\n        distributions[msg.sender].lastClaim = uint64(block.timestamp);\\n\\n        // Send account the tokens that they've accrued since their last claim.\\n        baoToken.transfer(msg.sender, _claimable);\\n\\n        // Emit tokens claimed event for logging\\n        emit TokensClaimed(msg.sender, _claimable);\\n    }\\n\\n    /**\\n     * Claim all tokens that have been accrued since msg.sender's last claim AND\\n     * the rest of the total locked amount owed immediately at a pre-defined slashed rate.\\n     *\\n     * Slash Rate:\\n     * days_since_start <= 365: (100 - .01369863013 * days_since_start)%\\n     * days_since_start > 365: 95%\\n     */\\n    function endDistribution() external nonReentrant {\\n        uint256 _claimable = claimable(msg.sender, 0);\\n        if (_claimable == 0) {\\n            revert ZeroClaimable();\\n        }\\n\\n        DistInfo storage distInfo = distributions[msg.sender];\\n        uint64 timestamp = uint64(block.timestamp);\\n\\n        uint256 daysSinceStart = FixedPointMathLibrary.mulDivDown(uint256(timestamp - distInfo.dateStarted), 1e18, 86400);\\n\\n        // Calculate total tokens left in distribution after the above claim\\n        uint256 tokensLeft = distInfo.amountOwedTotal - distCurve(distInfo.amountOwedTotal, daysSinceStart);\\n\\n        // Calculate slashed amount\\n        uint256 slash = FixedPointMathLibrary.mulDivDown(\\n            daysSinceStart > 365e18 ? 95e16 : 1e18 - FixedPointMathLibrary.mulDivDown(daysSinceStart, 1369863013, 1e13),\\n            tokensLeft,\\n            1e18\\n        );\\n        uint256 owed = tokensLeft - slash;\\n\\n        // Account gets slashed for (slash / tokensLeft)% of their remaining distribution\\n        baoToken.transfer(msg.sender, owed + _claimable);\\n        // Protocol treasury receives slashed tokens\\n        baoToken.transfer(treasury, slash);\\n\\n        // Update DistInfo storage for account to reflect the end of the account's distribution\\n        distInfo.lastClaim = timestamp;\\n        distInfo.dateEnded = timestamp;\\n\\n        // Emit tokens claimed event for logging\\n        emit TokensClaimed(msg.sender, _claimable);\\n        // Emit distribution ended event for logging\\n        emit DistributionEnded(msg.sender, owed);\\n    }\\n\\n    /**\\n     * Lock all tokens that have NOT been claimed since msg.sender's last claim\\n     *\\n     * The Lock into veBAO will be set at _time with this function in-line with length of distribution curve (minimum of 3 years)\\n     */\\n    function lockDistribution(uint256 _time) external nonReentrant {\\n        if (lockStatus[msg.sender] == true) {\\n            revert alreadyLocked();\\n        }\\n        uint256 _claimable = claimable(msg.sender, 0);\\n        if (_claimable == 0) {\\n            revert ZeroClaimable();\\n        }\\n        if (_time < block.timestamp + 94608000) {\\n            revert outsideLockRange();\\n        }\\n\\n        DistInfo storage distInfo = distributions[msg.sender];\\n        uint64 timestamp = uint64(block.timestamp);\\n\\n        uint256 daysSinceStart = FixedPointMathLibrary.mulDivDown(uint256(timestamp - distInfo.dateStarted), 1e18, 86400);\\n\\n        // Calculate total tokens left in distribution after the above claim\\n        uint256 tokensLeft = distInfo.amountOwedTotal - distCurve(distInfo.amountOwedTotal, daysSinceStart);\\n\\n        baoToken.approve(address(votingEscrow), tokensLeft);\\n\\n        //lock tokensLeft for msg.sender for _time years (minimum of 3 years)\\n        votingEscrow.create_lock_for(msg.sender, tokensLeft, _time);\\n\\n        lockStatus[msg.sender] = true;\\n        distInfo.dateEnded = timestamp;\\n\\n        emit DistributionLocked(msg.sender, tokensLeft);\\n    }\\n\\n    /**\\n     * Get how many tokens an account is able to claim at a given timestamp. 0 = now.\\n     * This function takes into account the date of the account's last claim, and returns the amount\\n     * of tokens they've accrued since.\\n     *\\n     * @param _account Account address to query.\\n     * @param _timestamp Timestamp to query.\\n     * @return c _account's claimable tokens, scaled by 1e18.\\n     */\\n    function claimable(address _account, uint64 _timestamp) public view returns (uint256 c) {\\n        DistInfo memory distInfo = distributions[_account];\\n        uint64 dateStarted = distInfo.dateStarted;\\n        if (dateStarted == 0) {\\n            revert ZeroClaimable();\\n        } else if (distInfo.dateEnded != 0) {\\n            revert DistributionEndedEarly();\\n        }\\n\\n        uint64 timestamp = _timestamp == 0 ? uint64(block.timestamp) : _timestamp;\\n        if (timestamp < dateStarted) {\\n            revert InvalidTimestamp();\\n        }\\n\\n        uint256 daysSinceStart = FixedPointMathLibrary.mulDivDown(uint256(timestamp - dateStarted), 1e18, 86400);\\n        uint256 daysSinceClaim = FixedPointMathLibrary.mulDivDown(uint256(timestamp - distInfo.lastClaim), 1e18, 86400);\\n\\n        // Allow the account to claim all tokens accrued since the last time they've claimed.\\n        uint256 _total = distInfo.amountOwedTotal;\\n        c = distCurve(_total, daysSinceStart) - distCurve(_total, daysSinceStart - daysSinceClaim);\\n    }\\n\\n    /**\\n     * Get the amount of tokens that would have been accrued along the distribution curve, assuming _daysSinceStart\\n     * days have passed and the account has never claimed.\\n     *\\n     * f(x) = 0 <= x <= 1095 : (2x/219)^2\\n     *\\n     * @param _amountOwedTotal Total amount of tokens owed, scaled by 1e18.\\n     * @param _daysSinceStart Time since the start of the distribution, scaled by 1e18.\\n     * @return _amount Amount of tokens accrued on the distribution curve, assuming the time passed is _daysSinceStart.\\n     */\\n    function distCurve(uint256 _amountOwedTotal, uint256 _daysSinceStart) public pure returns (uint256 _amount) {\\n        if (_daysSinceStart >= 1095e18) return _amountOwedTotal;\\n\\n        assembly {\\n            // Solmate's mulDivDown function\\n            function mulDivDown(x, y, denominator) -> z {\\n                // Store x * y in z for now.\\n                z := mul(x, y)\\n\\n                // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n                if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                    revert(0, 0)\\n                }\\n\\n                // Divide z by the denominator.\\n                z := div(z, denominator)\\n            }\\n\\n            // This is disgusting, but its more gas efficient than storing the results in `_amount` each time.\\n            _amount := mulDivDown( // Multiply `amountOwedTotal` by distribution curve result\\n                div( // Correct precision after exponent op (scale down by 1e20 instead of 1e18 to convert % to a proportion)\\n                    exp( // Raise result to the power of two\\n                        mulDivDown( // (2/219) * `_daysSinceStart`\\n                            mulDivDown(0x1BC16D674EC80000, 0xDE0B6B3A7640000, 0xBDF3C4BB0328C0000),\\n                            _daysSinceStart,\\n                            0xDE0B6B3A7640000\\n                        ),\\n                        2\\n                    ),\\n                    0xDE0B6B3A7640000\\n                ),\\n                _amountOwedTotal,\\n                0x56BC75E2D63100000\\n            )\\n        }\\n    }\\n\\n    // -------------------------------\\n    // PRIVATE FUNCTIONS\\n    // -------------------------------\\n\\n    /**\\n     * Verifies a merkle proof against the stored root.\\n     *\\n     * @param _proof Merkle proof.\\n     * @param _leaf Leaf to verify.\\n     * @return bool True if proof is valid, false if proof is invalid.\\n     */\\n    function verifyProof(bytes32[] memory _proof, bytes32 _leaf) private view returns (bool) {\\n        return MerkleProof.verify(_proof, merkleRoot, _leaf);\\n    }\\n}\",\"keccak256\":\"0x6fc02f237cc118c4a4fe8046c17ea163d60068d6bead72cfc84803392666493a\",\"license\":\"GPL-3.0\"}},\"version\":1}",
  "bytecode": "0x60a0604052600160005534801561001557600080fd5b5060405161118a38038061118a83398101604081905261003491610098565b600180546001600160a01b039586166001600160a01b0319918216179091556002805494861694821694909417909355608091909152600580549190931691161790556100e5565b80516001600160a01b038116811461009357600080fd5b919050565b600080600080608085870312156100ae57600080fd5b6100b78561007c565b93506100c56020860161007c565b9250604085015191506100da6060860161007c565b905092959194509250565b6080516110836101076000396000818161010b0152610c8b01526110836000f3fe608060405234801561001057600080fd5b50600436106100b45760003560e01c806364c761171161007157806364c7611714610181578063711bc2cc146101895780639353b9df1461019c578063c2a395941461021a578063ecb16c951461022d578063f0f140561461024057600080fd5b80631287d614146100b957806315497d2c146100ce5780632eb4a7ab146101065780634e71d92d1461013b5780634f2bfe5b1461014357806361d027b31461016e575b600080fd5b6100cc6100c7366004610d77565b610253565b005b6100f16100dc366004610e56565b60046020526000908152604090205460ff1681565b60405190151581526020015b60405180910390f35b61012d7f000000000000000000000000000000000000000000000000000000000000000081565b6040519081526020016100fd565b6100cc6103df565b600254610156906001600160a01b031681565b6040516001600160a01b0390911681526020016100fd565b600554610156906001600160a01b031681565b6100cc61051f565b6100cc610197366004610e71565b61081d565b6101e56101aa366004610e56565b600360205260009081526040902080546001909101546001600160401b0380831692600160401b8104821692600160801b9091049091169084565b6040516100fd94939291906001600160401b039485168152928416602084015292166040820152606081019190915260800190565b61012d610228366004610e8a565b610a90565b600154610156906001600160a01b031681565b61012d61024e366004610ecd565b610be4565b336000908152600360205260409020546001600160401b03161561028a5760405163e0e70c4960e01b815260040160405180910390fd5b6040516bffffffffffffffffffffffff193360601b166020820152603481018290526102d090839060540160405160208183030381529060405280519060200120610c83565b6102fc57338183604051630bcc64c960e21b81526004016102f393929190610eef565b60405180910390fd5b60408051608081018252426001600160401b0381168083526000602084015292820192909252606081016103326103e885610f62565b9052336000818152600360209081526040918290208451815486840151878601516001600160401b03908116600160801b0267ffffffffffffffff60801b19928216600160401b026fffffffffffffffffffffffffffffffff1990941691909416179190911716178155606090940151600190940193909355519081527fab67d7ea3f6d1612bda63a01384162c8ee0decb1b35cab6c6ff10dbe0e7d57e0910160405180910390a1505050565b6000546001146104015760405162461bcd60e51b81526004016102f390610f84565b600260009081556104123382610a90565b9050806000036104355760405163be7538fb60e01b815260040160405180910390fd5b3360008181526003602052604090819020805467ffffffffffffffff60801b1916600160801b426001600160401b031602179055600154905163a9059cbb60e01b81526004810192909252602482018390526001600160a01b03169063a9059cbb906044016020604051808303816000875af11580156104b9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104dd9190610fa8565b5060408051338152602081018390527f896e034966eaaf1adc54acc0f257056febbd300c9e47182cf761982cf1f5e430910160405180910390a1506001600055565b6000546001146105415760405162461bcd60e51b81526004016102f390610f84565b600260009081556105523382610a90565b9050806000036105755760405163be7538fb60e01b815260040160405180910390fd5b3360009081526003602052604081208054909142916105bc906105a1906001600160401b031684610fd1565b6001600160401b0316670de0b6b3a764000062015180610cb0565b905060006105ce846001015483610be4565b84600101546105dd9190610ff8565b905060006106396813c9647e25a9940000841161062057610609846351a673656509184e72a000610cb0565b61061b90670de0b6b3a7640000610ff8565b61062a565b670d2f13f7789f00005b83670de0b6b3a7640000610cb0565b905060006106478284610ff8565b6001549091506001600160a01b031663a9059cbb336106668a8561100b565b6040516001600160e01b031960e085901b1681526001600160a01b03909216600483015260248201526044016020604051808303816000875af11580156106b1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106d59190610fa8565b5060015460055460405163a9059cbb60e01b81526001600160a01b0391821660048201526024810185905291169063a9059cbb906044016020604051808303816000875af115801561072b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061074f9190610fa8565b50855477ffffffffffffffffffffffffffffffff00000000000000001916600160801b6001600160401b03871690810267ffffffffffffffff60401b191691909117600160401b9190910217865560408051338152602081018990527f896e034966eaaf1adc54acc0f257056febbd300c9e47182cf761982cf1f5e430910160405180910390a160408051338152602081018390527f5367ccf79b9a526d66835ee11189c8c710ba3ef031629c51977139111d90b953910160405180910390a1505060016000555050505050565b60005460011461083f5760405162461bcd60e51b81526004016102f390610f84565b600260009081553381526004602052604090205460ff16151560010361087857604051637e2f954760e01b815260040160405180910390fd5b6000610885336000610a90565b9050806000036108a85760405163be7538fb60e01b815260040160405180910390fd5b6108b6426305a39a8061100b565b8210156108d65760405163d6cf6c6760e01b815260040160405180910390fd5b336000908152600360205260408120805490914291610902906105a1906001600160401b031684610fd1565b90506000610914846001015483610be4565b84600101546109239190610ff8565b60015460025460405163095ea7b360e01b81526001600160a01b03918216600482015260248101849052929350169063095ea7b3906044016020604051808303816000875af115801561097a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061099e9190610fa8565b50600254604051633e173b2960e01b815233600482015260248101839052604481018890526001600160a01b0390911690633e173b2990606401600060405180830381600087803b1580156109f257600080fd5b505af1158015610a06573d6000803e3d6000fd5b5050336000818152600460209081526040918290208054600160ff19909116179055885467ffffffffffffffff60401b1916600160401b6001600160401b038a1602178955815192835282018590527f8bcae1a205c9e844b0492205ba6ad2b480293ba662b8d7105268451eb7b78d2f935001905060405180910390a15050600160005550505050565b6001600160a01b0382166000908152600360209081526040808320815160808101835281546001600160401b03808216808452600160401b8304821696840196909652600160801b909104169281019290925260010154606082015290808303610b0d5760405163be7538fb60e01b815260040160405180910390fd5b60208201516001600160401b031615610b395760405163bc21cd9360e01b815260040160405180910390fd5b60006001600160401b03851615610b505784610b52565b425b9050816001600160401b0316816001600160401b03161015610b875760405163b7d0949760e01b815260040160405180910390fd5b6000610b966105a18484610fd1565b90506000610bad8560400151846105a19190610fd1565b6060860151909150610bc38161024e8486610ff8565b610bcd8285610be4565b610bd79190610ff8565b9998505050505050505050565b6000683b5c2d7a70fcbc00008210610bfd575081610c7d565b610c24565b808202831515821583830485141716610c1a57600080fd5b9290920492915050565b610c7a68056bc75e2d6310000084670de0b6b3a76400006002610c73670de0b6b3a764000088610c6e680bdf3c4bb0328c0000670de0b6b3a7640000671bc16d674ec80000610c02565b610c02565b0a04610c02565b90505b92915050565b6000610c7a837f000000000000000000000000000000000000000000000000000000000000000084610ccf565b828202811515841585830485141716610cc857600080fd5b0492915050565b600082610cdc8584610ce5565b14949350505050565b600081815b8451811015610d2a57610d1682868381518110610d0957610d0961101e565b6020026020010151610d32565b915080610d2281611034565b915050610cea565b509392505050565b6000818310610d4e576000828152602084905260409020610c7a565b6000838152602083905260409020610c7a565b634e487b7160e01b600052604160045260246000fd5b60008060408385031215610d8a57600080fd5b82356001600160401b0380821115610da157600080fd5b818501915085601f830112610db557600080fd5b8135602082821115610dc957610dc9610d61565b8160051b604051601f19603f83011681018181108682111715610dee57610dee610d61565b604052928352818301935084810182019289841115610e0c57600080fd5b948201945b83861015610e2a57853585529482019493820193610e11565b9997909101359750505050505050565b80356001600160a01b0381168114610e5157600080fd5b919050565b600060208284031215610e6857600080fd5b610c7a82610e3a565b600060208284031215610e8357600080fd5b5035919050565b60008060408385031215610e9d57600080fd5b610ea683610e3a565b915060208301356001600160401b0381168114610ec257600080fd5b809150509250929050565b60008060408385031215610ee057600080fd5b50508035926020909101359150565b6001600160a01b038416815260208082018490526060604083018190528351908301819052600091848101916080850190845b81811015610f3e57845183529383019391830191600101610f22565b509098975050505050505050565b634e487b7160e01b600052601160045260246000fd5b600082610f7f57634e487b7160e01b600052601260045260246000fd5b500490565b6020808252600a90820152695245454e5452414e435960b01b604082015260600190565b600060208284031215610fba57600080fd5b81518015158114610fca57600080fd5b9392505050565b6001600160401b03828116828216039080821115610ff157610ff1610f4c565b5092915050565b81810381811115610c7d57610c7d610f4c565b80820180821115610c7d57610c7d610f4c565b634e487b7160e01b600052603260045260246000fd5b60006001820161104657611046610f4c565b506001019056fea264697066735822122017a5850431d77d69fe840581eb6e10d56c3dfc7c566613a013d65026447d395364736f6c63430008110033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100b45760003560e01c806364c761171161007157806364c7611714610181578063711bc2cc146101895780639353b9df1461019c578063c2a395941461021a578063ecb16c951461022d578063f0f140561461024057600080fd5b80631287d614146100b957806315497d2c146100ce5780632eb4a7ab146101065780634e71d92d1461013b5780634f2bfe5b1461014357806361d027b31461016e575b600080fd5b6100cc6100c7366004610d77565b610253565b005b6100f16100dc366004610e56565b60046020526000908152604090205460ff1681565b60405190151581526020015b60405180910390f35b61012d7f000000000000000000000000000000000000000000000000000000000000000081565b6040519081526020016100fd565b6100cc6103df565b600254610156906001600160a01b031681565b6040516001600160a01b0390911681526020016100fd565b600554610156906001600160a01b031681565b6100cc61051f565b6100cc610197366004610e71565b61081d565b6101e56101aa366004610e56565b600360205260009081526040902080546001909101546001600160401b0380831692600160401b8104821692600160801b9091049091169084565b6040516100fd94939291906001600160401b039485168152928416602084015292166040820152606081019190915260800190565b61012d610228366004610e8a565b610a90565b600154610156906001600160a01b031681565b61012d61024e366004610ecd565b610be4565b336000908152600360205260409020546001600160401b03161561028a5760405163e0e70c4960e01b815260040160405180910390fd5b6040516bffffffffffffffffffffffff193360601b166020820152603481018290526102d090839060540160405160208183030381529060405280519060200120610c83565b6102fc57338183604051630bcc64c960e21b81526004016102f393929190610eef565b60405180910390fd5b60408051608081018252426001600160401b0381168083526000602084015292820192909252606081016103326103e885610f62565b9052336000818152600360209081526040918290208451815486840151878601516001600160401b03908116600160801b0267ffffffffffffffff60801b19928216600160401b026fffffffffffffffffffffffffffffffff1990941691909416179190911716178155606090940151600190940193909355519081527fab67d7ea3f6d1612bda63a01384162c8ee0decb1b35cab6c6ff10dbe0e7d57e0910160405180910390a1505050565b6000546001146104015760405162461bcd60e51b81526004016102f390610f84565b600260009081556104123382610a90565b9050806000036104355760405163be7538fb60e01b815260040160405180910390fd5b3360008181526003602052604090819020805467ffffffffffffffff60801b1916600160801b426001600160401b031602179055600154905163a9059cbb60e01b81526004810192909252602482018390526001600160a01b03169063a9059cbb906044016020604051808303816000875af11580156104b9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104dd9190610fa8565b5060408051338152602081018390527f896e034966eaaf1adc54acc0f257056febbd300c9e47182cf761982cf1f5e430910160405180910390a1506001600055565b6000546001146105415760405162461bcd60e51b81526004016102f390610f84565b600260009081556105523382610a90565b9050806000036105755760405163be7538fb60e01b815260040160405180910390fd5b3360009081526003602052604081208054909142916105bc906105a1906001600160401b031684610fd1565b6001600160401b0316670de0b6b3a764000062015180610cb0565b905060006105ce846001015483610be4565b84600101546105dd9190610ff8565b905060006106396813c9647e25a9940000841161062057610609846351a673656509184e72a000610cb0565b61061b90670de0b6b3a7640000610ff8565b61062a565b670d2f13f7789f00005b83670de0b6b3a7640000610cb0565b905060006106478284610ff8565b6001549091506001600160a01b031663a9059cbb336106668a8561100b565b6040516001600160e01b031960e085901b1681526001600160a01b03909216600483015260248201526044016020604051808303816000875af11580156106b1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106d59190610fa8565b5060015460055460405163a9059cbb60e01b81526001600160a01b0391821660048201526024810185905291169063a9059cbb906044016020604051808303816000875af115801561072b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061074f9190610fa8565b50855477ffffffffffffffffffffffffffffffff00000000000000001916600160801b6001600160401b03871690810267ffffffffffffffff60401b191691909117600160401b9190910217865560408051338152602081018990527f896e034966eaaf1adc54acc0f257056febbd300c9e47182cf761982cf1f5e430910160405180910390a160408051338152602081018390527f5367ccf79b9a526d66835ee11189c8c710ba3ef031629c51977139111d90b953910160405180910390a1505060016000555050505050565b60005460011461083f5760405162461bcd60e51b81526004016102f390610f84565b600260009081553381526004602052604090205460ff16151560010361087857604051637e2f954760e01b815260040160405180910390fd5b6000610885336000610a90565b9050806000036108a85760405163be7538fb60e01b815260040160405180910390fd5b6108b6426305a39a8061100b565b8210156108d65760405163d6cf6c6760e01b815260040160405180910390fd5b336000908152600360205260408120805490914291610902906105a1906001600160401b031684610fd1565b90506000610914846001015483610be4565b84600101546109239190610ff8565b60015460025460405163095ea7b360e01b81526001600160a01b03918216600482015260248101849052929350169063095ea7b3906044016020604051808303816000875af115801561097a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061099e9190610fa8565b50600254604051633e173b2960e01b815233600482015260248101839052604481018890526001600160a01b0390911690633e173b2990606401600060405180830381600087803b1580156109f257600080fd5b505af1158015610a06573d6000803e3d6000fd5b5050336000818152600460209081526040918290208054600160ff19909116179055885467ffffffffffffffff60401b1916600160401b6001600160401b038a1602178955815192835282018590527f8bcae1a205c9e844b0492205ba6ad2b480293ba662b8d7105268451eb7b78d2f935001905060405180910390a15050600160005550505050565b6001600160a01b0382166000908152600360209081526040808320815160808101835281546001600160401b03808216808452600160401b8304821696840196909652600160801b909104169281019290925260010154606082015290808303610b0d5760405163be7538fb60e01b815260040160405180910390fd5b60208201516001600160401b031615610b395760405163bc21cd9360e01b815260040160405180910390fd5b60006001600160401b03851615610b505784610b52565b425b9050816001600160401b0316816001600160401b03161015610b875760405163b7d0949760e01b815260040160405180910390fd5b6000610b966105a18484610fd1565b90506000610bad8560400151846105a19190610fd1565b6060860151909150610bc38161024e8486610ff8565b610bcd8285610be4565b610bd79190610ff8565b9998505050505050505050565b6000683b5c2d7a70fcbc00008210610bfd575081610c7d565b610c24565b808202831515821583830485141716610c1a57600080fd5b9290920492915050565b610c7a68056bc75e2d6310000084670de0b6b3a76400006002610c73670de0b6b3a764000088610c6e680bdf3c4bb0328c0000670de0b6b3a7640000671bc16d674ec80000610c02565b610c02565b0a04610c02565b90505b92915050565b6000610c7a837f000000000000000000000000000000000000000000000000000000000000000084610ccf565b828202811515841585830485141716610cc857600080fd5b0492915050565b600082610cdc8584610ce5565b14949350505050565b600081815b8451811015610d2a57610d1682868381518110610d0957610d0961101e565b6020026020010151610d32565b915080610d2281611034565b915050610cea565b509392505050565b6000818310610d4e576000828152602084905260409020610c7a565b6000838152602083905260409020610c7a565b634e487b7160e01b600052604160045260246000fd5b60008060408385031215610d8a57600080fd5b82356001600160401b0380821115610da157600080fd5b818501915085601f830112610db557600080fd5b8135602082821115610dc957610dc9610d61565b8160051b604051601f19603f83011681018181108682111715610dee57610dee610d61565b604052928352818301935084810182019289841115610e0c57600080fd5b948201945b83861015610e2a57853585529482019493820193610e11565b9997909101359750505050505050565b80356001600160a01b0381168114610e5157600080fd5b919050565b600060208284031215610e6857600080fd5b610c7a82610e3a565b600060208284031215610e8357600080fd5b5035919050565b60008060408385031215610e9d57600080fd5b610ea683610e3a565b915060208301356001600160401b0381168114610ec257600080fd5b809150509250929050565b60008060408385031215610ee057600080fd5b50508035926020909101359150565b6001600160a01b038416815260208082018490526060604083018190528351908301819052600091848101916080850190845b81811015610f3e57845183529383019391830191600101610f22565b509098975050505050505050565b634e487b7160e01b600052601160045260246000fd5b600082610f7f57634e487b7160e01b600052601260045260246000fd5b500490565b6020808252600a90820152695245454e5452414e435960b01b604082015260600190565b600060208284031215610fba57600080fd5b81518015158114610fca57600080fd5b9392505050565b6001600160401b03828116828216039080821115610ff157610ff1610f4c565b5092915050565b81810381811115610c7d57610c7d610f4c565b80820180821115610c7d57610c7d610f4c565b634e487b7160e01b600052603260045260246000fd5b60006001820161104657611046610f4c565b506001019056fea264697066735822122017a5850431d77d69fe840581eb6e10d56c3dfc7c566613a013d65026447d395364736f6c63430008110033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "claimable(address,uint64)": {
        "params": {
          "_account": "Account address to query.",
          "_timestamp": "Timestamp to query."
        },
        "returns": {
          "c": "_account's claimable tokens, scaled by 1e18."
        }
      },
      "constructor": {
        "params": {
          "_baoToken": "Token to distribute.",
          "_merkleRoot": "Merkle root to verify accounts' inclusion and amount owed when starting their distribution.",
          "_votingEscrow": "vote escrow BAO contract"
        }
      },
      "distCurve(uint256,uint256)": {
        "params": {
          "_amountOwedTotal": "Total amount of tokens owed, scaled by 1e18.",
          "_daysSinceStart": "Time since the start of the distribution, scaled by 1e18."
        },
        "returns": {
          "_amount": "Amount of tokens accrued on the distribution curve, assuming the time passed is _daysSinceStart."
        }
      },
      "startDistribution(bytes32[],uint256)": {
        "params": {
          "_amount": "Amount of tokens msg.sender is owed. Used to generate the merkle tree leaf.",
          "_proof": "Merkle proof to verify msg.sender's inclusion and claimed amount."
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "claim()": {
        "notice": "Claim all tokens that have been accrued since msg.sender's last claim."
      },
      "claimable(address,uint64)": {
        "notice": "Get how many tokens an account is able to claim at a given timestamp. 0 = now. This function takes into account the date of the account's last claim, and returns the amount of tokens they've accrued since."
      },
      "constructor": {
        "notice": "Create a new BaoDistribution contract."
      },
      "distCurve(uint256,uint256)": {
        "notice": "Get the amount of tokens that would have been accrued along the distribution curve, assuming _daysSinceStart days have passed and the account has never claimed. f(x) = 0 <= x <= 1095 : (2x/219)^2"
      },
      "endDistribution()": {
        "notice": "Claim all tokens that have been accrued since msg.sender's last claim AND the rest of the total locked amount owed immediately at a pre-defined slashed rate. Slash Rate: days_since_start <= 365: (100 - .01369863013 * days_since_start)% days_since_start > 365: 95%"
      },
      "lockDistribution(uint256)": {
        "notice": "Lock all tokens that have NOT been claimed since msg.sender's last claim The Lock into veBAO will be set at _time with this function in-line with length of distribution curve (minimum of 3 years)"
      },
      "startDistribution(bytes32[],uint256)": {
        "notice": "Starts the distribution of BAO for msg.sender."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 581,
        "contract": "contracts/BaoDistribution.sol:BaoDistribution",
        "label": "locked",
        "offset": 0,
        "slot": "0",
        "type": "t_uint256"
      },
      {
        "astId": 733,
        "contract": "contracts/BaoDistribution.sol:BaoDistribution",
        "label": "baoToken",
        "offset": 0,
        "slot": "1",
        "type": "t_contract(IERC20)577"
      },
      {
        "astId": 736,
        "contract": "contracts/BaoDistribution.sol:BaoDistribution",
        "label": "votingEscrow",
        "offset": 0,
        "slot": "2",
        "type": "t_contract(IVotingEscrow)728"
      },
      {
        "astId": 741,
        "contract": "contracts/BaoDistribution.sol:BaoDistribution",
        "label": "distributions",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_address,t_struct(DistInfo)758_storage)"
      },
      {
        "astId": 745,
        "contract": "contracts/BaoDistribution.sol:BaoDistribution",
        "label": "lockStatus",
        "offset": 0,
        "slot": "4",
        "type": "t_mapping(t_address,t_bool)"
      },
      {
        "astId": 747,
        "contract": "contracts/BaoDistribution.sol:BaoDistribution",
        "label": "treasury",
        "offset": 0,
        "slot": "5",
        "type": "t_address"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_contract(IERC20)577": {
        "encoding": "inplace",
        "label": "contract IERC20",
        "numberOfBytes": "20"
      },
      "t_contract(IVotingEscrow)728": {
        "encoding": "inplace",
        "label": "contract IVotingEscrow",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_address,t_struct(DistInfo)758_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct BaoDistribution.DistInfo)",
        "numberOfBytes": "32",
        "value": "t_struct(DistInfo)758_storage"
      },
      "t_struct(DistInfo)758_storage": {
        "encoding": "inplace",
        "label": "struct BaoDistribution.DistInfo",
        "members": [
          {
            "astId": 751,
            "contract": "contracts/BaoDistribution.sol:BaoDistribution",
            "label": "dateStarted",
            "offset": 0,
            "slot": "0",
            "type": "t_uint64"
          },
          {
            "astId": 753,
            "contract": "contracts/BaoDistribution.sol:BaoDistribution",
            "label": "dateEnded",
            "offset": 8,
            "slot": "0",
            "type": "t_uint64"
          },
          {
            "astId": 755,
            "contract": "contracts/BaoDistribution.sol:BaoDistribution",
            "label": "lastClaim",
            "offset": 16,
            "slot": "0",
            "type": "t_uint64"
          },
          {
            "astId": 757,
            "contract": "contracts/BaoDistribution.sol:BaoDistribution",
            "label": "amountOwedTotal",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint64": {
        "encoding": "inplace",
        "label": "uint64",
        "numberOfBytes": "8"
      }
    }
  }
}